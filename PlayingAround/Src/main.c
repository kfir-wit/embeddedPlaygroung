/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

/*
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/

void debounce (void)
{
	for (uint32_t i=0; i<250000; i++);
}

int main(void)
{
	/*
	 in general, the procedure is as follows:
	 1. identify the GPIO port. GPIOD in our case.
	 2. identify the GPIO pin. pin 12 for GREEN LED (13 is orange 14 is red, 15 is blue. all in GPIOD)
	 3. activate peripheral (enable clock) per correct bus and port (AHB1, port D in our case)
	 4. configure the GPIO pin mode as mode as "output"
	 5. write to the GPIO pin (1 = on; 0 = off)

	 */


	// setting GPIO state for LEDs
	RCC_AHB1ENR_t volatile *pClkCtrlReg_a = (RCC_AHB1ENR_t*)0x40023830;
	GPIOx_MODER_t volatile *pPortDModeReg_a = (GPIOx_MODER_t*)0x40020C00;
	GPIOx_MODER_t *pPortAModeReg_a = (GPIOx_MODER_t*)0x40020000;
	GPIOx_IDR_t volatile *const pPortAInReg_a = (GPIOx_IDR_t*)0x40020010;
	uint32_t volatile *pPortDOutReg= (uint32_t*)0x40020C14;
	GPIOx_IODR_t volatile *pOutputDataReg = (GPIOx_IODR_t*)(0x40020C00 + 0x14);
	GPIOx_IODR_t volatile *pInputDataReg = (GPIOx_IODR_t*)(0x40020C00 + 0x10);


	// general setup for keypad
	GPIOx_MODER_t volatile *pPortDModeReg = (GPIOx_MODER_t*)0x40020C00;
	GPIOx_MODER_t volatile *pPullupDownReg = (GPIOx_MODER_t*)(0x40020C00 + 0x0C); // 0x0C offset for pullup/pulldown
	RCC_AHB1ENR_t volatile *pClkCtrlReg = (RCC_AHB1ENR_t*)0x40023830;


	pClkCtrlReg->gpioa_en = 0x1; // for toggle input, not keypad
	pClkCtrlReg->gpiod_en = 0x1; // for keypad and LEDs


	// setting 4 GPIO states for rows (output) // ?10 for pull-down?
	pPortDModeReg->moder0 = 0x01;
	pOutputDataReg->dr0 = 0x1;
	pPortDModeReg->moder1 = 0x01;
	pOutputDataReg->dr1 = 0x1;
	pPortDModeReg->moder2 = 0x01;
	pOutputDataReg->dr2 = 0x1;
	pPortDModeReg->moder3 = 0x01;
	pOutputDataReg->dr3 = 0x1;

	// setting 3 GPIO states for columns (input) // 01 for pull-up
	pPortDModeReg->moder8 = 0x00;
	pPullupDownReg->moder8 = 0x01;
	pPortDModeReg->moder9 = 0x00;
	pPullupDownReg->moder9 = 0x01;
	pPortDModeReg->moder10 = 0x00;
	pPullupDownReg->moder10 = 0x01;





	short volatile PA0Status; // 0 is Low, 1 is High

	// initiate peripheral clock
	pClkCtrlReg_a->gpioa_en = 0x1;
	//*pClkCtrlReg |= 1; // enable port A

	pClkCtrlReg_a->gpiod_en = 0x1;
	//*pClkCtrlReg |= (1<<3); // enable port D

	// LED output configuration

	// set Port D to Green: output
	pPortDModeReg_a->moder12 = 0x01;

	// set Port D to Orange: output
	pPortDModeReg_a->moder13 = 0x01;

	// set Port D to Red: output
	pPortDModeReg_a->moder14 = 0x01;

	// set Port D to Blue: output
	pPortDModeReg_a->moder15 = 0x01;

	// set Port D output to 1 (High)
	*pPortDOutReg |=0x1000; // LED On


	// Vdd toggler

	// set Port A to PA0 input; read bit 0
	pPortAModeReg_a->moder0 = 0x00;
	PA0Status = pPortAInReg_a->idr0;


	// Keypad loop




    /* Loop forever */
	for (int counter=0;;counter++) {

	//keypad loop

		for (uint32_t row = 0; row <4; row++)
		{
			pOutputDataReg->dr0 = 0x1;
			pOutputDataReg->dr1 = 0x1;
			pOutputDataReg->dr2 = 0x1;
			pOutputDataReg->dr3 = 0x1;

			switch (row) {
			case 0:
				pOutputDataReg->dr0 = 0x0;
				break;
			case 1:
				pOutputDataReg->dr1 = 0x0;
				break;
			case 2:
				pOutputDataReg->dr2 = 0x0;
				break;
			case 3:
				pOutputDataReg->dr3 = 0x0;
				break;
			}

			int keyPressed, column;

		     if (!(pInputDataReg->dr8)) {
		    	 // column 1 / row 1 was pressed... do something
		    	 column = 1;
		    	 if (!(row==3)) {
		    		 keyPressed = 3 * row + column;
		    		 printf("%i\n",keyPressed);
		    	 }
		    	 else {
		    		 printf("*\n");
		    	 }
		    	 debounce();
		     }

		     if (!(pInputDataReg->dr9)) {
		    	 // column 1 / row 1 was pressed... do something
		    	 column = 2;
		    	 if (!(row==3)) {
		    		 keyPressed = 3 * row + column;
		    		 printf("%i\n",keyPressed);
		    	 }
		    	 else {
		    		 printf("0\n");
		    	 }
		    	 debounce();
		     }

		     if (!(pInputDataReg->dr10)) {
		    	 // column 1 / row 1 was pressed... do something
		    	 column = 3;
		    	 if (!(row==3)) {
		    		 keyPressed = 3 * row + column;
		    		 printf("%i\n",keyPressed);
		    	 }
		    	 else {
		    		 printf("#\n");
		    	 }
		    	 debounce();
		     }

		}

		/*
// handling first row

	pOutputDataReg->dr3 = 0x1; // setting row 4 to HIGH
	pOutputDataReg->dr0 = 0x0; // setting row 1 to LOW

     if (!(pInputDataReg->dr8)) {
    	 // column 1 / row 1 was pressed... do something
    	 debounce();
    	 printf("1\n");
     }

     if (!(pInputDataReg->dr9)) {
    	 // column 1 / row 1 was pressed... do something
    	 debounce();
    	 printf("2\n");
     }

     if (!(pInputDataReg->dr10)) {
    	 // column 1 / row 1 was pressed... do something
    	 debounce();
    	 printf("3\n");
     }

// handling second row

	  pOutputDataReg->dr0 = 0x1; // setting row 1 back to HIGH
	  pOutputDataReg->dr1 = 0x0; // setting row 2  to LOW


	  if (!(pInputDataReg->dr8)) {
		 // column 1 / row 2 was pressed... do something
		 debounce();
		 printf("4\n");
	  }

	  if (!(pInputDataReg->dr9)) {
		 // column 1 / row 2 was pressed... do something
		 debounce();
		 printf("5\n");
	  }

	  if (!(pInputDataReg->dr10)) {
		 // column 1 / row 2 was pressed... do something
		 debounce();
		 printf("6\n");
	  }

// handling third row

	pOutputDataReg->dr1 = 0x1; // setting row 2 back to HIGH
	pOutputDataReg->dr2 = 0x0; // setting row 3  to LOW


	if (!(pInputDataReg->dr8)) {
	// column 1 / row 3 was pressed... do something
	debounce();
	printf("7\n");
	}

	if (!(pInputDataReg->dr9)) {
	// column 1 / row 3 was pressed... do something
	debounce();
	printf("8\n");
	}

	if (!(pInputDataReg->dr10)) {
	// column 1 / row 3 was pressed... do something
	debounce();
	printf("9\n");
	}

// handling fourth row

	pOutputDataReg->dr2 = 0x1; // setting row 3 back to HIGH
	pOutputDataReg->dr3 = 0x0; // setting row 4 to LOW


	if (!(pInputDataReg->dr8)) {
	// column 1 / row 4 was pressed... do something
	debounce();
	printf("*\n");
	}

	if (!(pInputDataReg->dr9)) {
	// column 1 / row 4 was pressed... do something
	debounce();
	printf("0\n");
	}

	if (!(pInputDataReg->dr10)) {
	// column 1 / row 4 was pressed... do something
	debounce();
	printf("#\n");
	}


*/


		int color = (counter%4)+12;

		PA0Status = pPortAInReg_a->idr0;

		if (PA0Status) *pPortDOutReg ^=(1<<color); // not much use for abstraction at this point


		for (uint32_t volatile t=0; t < 100000; t++); //NOP delay, not accurate very sensitive to compiler optimization

	}
}
